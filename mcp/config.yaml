# MCP Stringwork Configuration
# Copy this file to ~/.config/stringwork/config.yaml and customize.

# Initial workspace root directory (used for file operation policy checks).
# Leave empty to use current working directory.
# Clients can dynamically change it at runtime via set_presence workspace='...'.
workspace_root: ""

# Log file path. Default: ~/.config/stringwork/mcp-stringwork.log
log_file: ""

# State file path. Default: ~/.config/stringwork/state.sqlite (shared globally).
state_file: ""

# Which tools to enable (use "*" for all, or list specific tool names)
enabled_tools:
  - "*"

# --- Collaboration Settings ---
message_retention_max: 1000
message_retention_days: 30
presence_ttl_seconds: 300

# --- Daemon mode (multi-driver support) ---
# When enabled, multiple Cursor windows share a single server process.
# The first invocation starts a background daemon; subsequent ones connect
# to it as thin stdio-to-HTTP proxies. Use --standalone flag to bypass.
daemon:
  enabled: true
  socket_path: ""            # default: ~/.config/stringwork/server.sock
  pid_file: ""               # default: ~/.config/stringwork/daemon.pid
  grace_period_seconds: 10   # wait before daemon exits after last driver disconnects

# --- HTTP port (for workers and dashboard) ---
# The server always runs an HTTP server for workers/dashboard.
# In standalone mode it also runs stdio for the driver.
# Set to 0 for auto-assigned port, or a fixed port (e.g. 8943) for a
# predictable dashboard URL. With daemon mode, port 0 is recommended since
# the daemon persists and the port stays stable across driver reconnects.
http_port: 0

# --- MCP Servers for Workers ---
# MCP servers to auto-register with worker CLIs (claude, codex, gemini) when
# they spawn. Stringwork itself is always auto-registered automatically.
# Supports URL-based (HTTP/SSE) and command-based (stdio) servers.
# For servers requiring auth, workers must log in manually once:
#   claude mcp login <name>   OR   codex mcp login <name>
#
# mcp_servers:
#   my-http-server:
#     url: "https://example.com/mcp"
#     auth: oauth                        # "oauth", "bearer", or omit for none
#   my-local-server:
#     command: npx
#     args: ["-y", "@some/mcp-server"]
#   playwright:
#     command: npx
#     args: ["@playwright/mcp@latest", "--browser", "chromium"]

# --- Features ---
features:
  knowledge:
    enabled: true               # Enable FTS5-based project knowledge indexer
    index_go_source: true       # Index Go source files (function signatures, comments)
    watch_interval_seconds: 60  # How often to sync session notes and task summaries

# --- Orchestration (driver + workers) ---
# One driver (e.g. Cursor) and N workers. The server spawns workers automatically
# when there's pending work -- no need to keep them running manually.
#
# MCP servers are auto-registered with worker CLIs using their native `mcp add`
# commands. Stringwork itself is always auto-registered; additional servers
# come from mcp_servers above.
#
# Worker spawn behavior:
#   - Startup recovery: checks for pending work on server (re)start
#   - Retry with backoff, timeout protection, failure/success acks
#
# Per worker: type, instances, command, cooldown_seconds, timeout_seconds,
# retry_delay_seconds, max_retries, env, inherit_env.
# Spawned processes get STRINGWORK_AGENT, STRINGWORK_WORKSPACE automatically.
#
# Environment control:
#   env:           Additional env vars. Values support ${VAR} expansion from parent env.
#   inherit_env:   Glob patterns for which parent env vars to pass through.
#                  Default (empty): inherit ALL parent env vars.
#                  Set to ["none"] for a clean environment.
orchestration:
  driver: cursor
  assignment_strategy: least_loaded    # or capability_match
  heartbeat_interval_seconds: 30
  worker_timeout_seconds: 120
  # Git worktree isolation (optional): each worker gets its own checkout.
  # worktrees:
  #   enabled: true
  #   base_branch: ""                  # empty = current HEAD
  #   cleanup_strategy: "on_cancel"    # on_cancel | on_exit | manual
  #   path: ".stringwork/worktrees"
  workers:
    - type: claude-code
      instances: 1
      command: ["claude", "-p", "You are claude-code in a pair programming session. Your workspace is {workspace}. Steps: 1) set_presence agent='claude-code' status='working' workspace='{workspace}' 2) read_messages for 'claude-code' 3) list_tasks assigned_to='claude-code' 4) Process ALL unread messages and pending tasks using your full tool suite (file edit, search, git, terminal, and all MCP tools). 5) report_progress every 2-3 minutes. 6) ALWAYS send_message from='claude-code' to='cursor' with detailed findings before finishing.", "--dangerously-skip-permissions"]
      cooldown_seconds: 30
      max_retries: 2
      retry_delay_seconds: 15
      timeout_seconds: 600
      env:
        GH_TOKEN: "${GH_TOKEN}"
        GITHUB_TOKEN: "${GITHUB_TOKEN}"
        SSH_AUTH_SOCK: "${SSH_AUTH_SOCK}"
      # inherit_env: ["HOME", "PATH", "GH_*", "SSH_*"]  # restrict inherited env
    - type: codex
      instances: 1
      # Codex sandbox blocks network by default.
      # Use --sandbox danger-full-access for full capabilities.
      command: ["codex", "exec", "--sandbox", "danger-full-access", "--skip-git-repo-check", "You are codex in a pair programming session. Your workspace is {workspace}. Steps: 1) set_presence agent='codex' status='working' workspace='{workspace}' 2) read_messages for 'codex' 3) list_tasks assigned_to='codex' 4) Process ALL unread messages and pending tasks using your full tool suite (file edit, search, terminal, and all MCP tools). 5) report_progress every 2-3 minutes. 6) ALWAYS send_message from='codex' to='cursor' with detailed findings before finishing."]
      cooldown_seconds: 30
      max_retries: 2
      retry_delay_seconds: 15
      timeout_seconds: 600
      env:
        GH_TOKEN: "${GH_TOKEN}"
        GITHUB_TOKEN: "${GITHUB_TOKEN}"
        SSH_AUTH_SOCK: "${SSH_AUTH_SOCK}"
    - type: gemini
      instances: 1
      # Gemini CLI: --yolo auto-approves tools, --prompt runs headless.
      # Requires GOOGLE_API_KEY. Install: npm install -g @google/gemini-cli
      command: ["gemini", "--yolo", "--prompt", "You are gemini in a pair programming session. Your workspace is {workspace}. Steps: 1) set_presence agent='gemini' status='working' workspace='{workspace}' 2) read_messages for 'gemini' 3) list_tasks assigned_to='gemini' 4) Process ALL unread messages and pending tasks using your full tool suite (file edit, search, terminal, and all MCP tools). 5) report_progress every 2-3 minutes. 6) ALWAYS send_message from='gemini' to='cursor' with detailed findings before finishing."]
      cooldown_seconds: 30
      max_retries: 2
      retry_delay_seconds: 15
      timeout_seconds: 600
      env:
        GOOGLE_API_KEY: "${GOOGLE_API_KEY}"
        GH_TOKEN: "${GH_TOKEN}"
        GITHUB_TOKEN: "${GITHUB_TOKEN}"
        SSH_AUTH_SOCK: "${SSH_AUTH_SOCK}"
